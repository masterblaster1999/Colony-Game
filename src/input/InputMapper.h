#pragma once

#include "input/InputEvent.h"

#include <array>
#include <bitset>
#include <cstddef>
#include <cstdint>
#include <span>

namespace colony::input {

// High-level actions produced by the input mapper.
//
// For now we only need movement actions for the debug camera (WASD + QE),
// but this enum is the seam where future gameplay actions should be added.
enum class Action : std::uint8_t {
    MoveForward = 0,
    MoveBackward,
    MoveLeft,
    MoveRight,
    MoveDown,
    MoveUp,

    // Modifier-style action that affects movement speed.
    SpeedBoost,

    Count
};

// Discrete action transitions generated by the mapper.
//
// The goal is for gameplay code to react to *actions* rather than raw keys.
// For continuous input (movement axes), you can still query IsDown()/GetMovementAxes().
enum class ActionEventType : std::uint8_t {
    Pressed = 0,
    Released = 1,
};

struct ActionEvent {
    Action action = Action::MoveForward;
    ActionEventType type = ActionEventType::Pressed;
};

struct MovementAxes {
    // x: strafe (right - left)
    // y: forward/back (forward - backward)
    // z: vertical (up - down)
    float x = 0.f;
    float y = 0.f;
    float z = 0.f;
};

// Maps raw key events to high-level actions.
//
// Notes:
//  - This intentionally stores Win32 virtual-key codes (0..255) as integers.
//    The rest of the game layer never sees Win32 types.
//  - Current implementation is designed for the prototype executable:
//    single-threaded, fed once per frame.
class InputMapper {
public:
    InputMapper() noexcept;

    void SetDefaultBinds() noexcept;

    // Clears all tracked key state (useful on focus loss).
    void ClearState() noexcept;

    // Multiple bindings per action.
    void ClearBindings(Action action) noexcept;
    void AddBinding(Action action, std::uint32_t vk) noexcept;
    void RemoveBinding(Action action, std::uint32_t vk) noexcept;
    [[nodiscard]] std::span<const std::uint32_t> Bindings(Action action) const noexcept;

    // Consumes key events and updates key state.
    // Returns true if any *action* changed (pressed/released) during this call.
    bool Consume(std::span<const InputEvent> events) noexcept;

    // Action transitions generated by the last Consume() call.
    [[nodiscard]] std::span<const ActionEvent> ActionEvents() const noexcept;

    [[nodiscard]] bool IsDown(Action action) const noexcept;

    [[nodiscard]] MovementAxes GetMovementAxes() const noexcept;

private:
    static constexpr std::size_t kVkCount = 256;

    static constexpr std::size_t kActionCount = static_cast<std::size_t>(Action::Count);
    static constexpr std::size_t kMaxBindingsPerAction = 4;
    static constexpr std::size_t kMaxActionEvents = 128;

    static constexpr std::size_t ToIndex(Action a) noexcept
    {
        return static_cast<std::size_t>(a);
    }

    void PushActionEvent(Action action, ActionEventType type) noexcept;
    [[nodiscard]] bool ComputeActionDown(Action action) const noexcept;
    void RecomputeActionStatesNoEvents() noexcept;
    void RefreshActionsAndEmitTransitions() noexcept;

    std::bitset<kVkCount> m_keysDown{};
    std::array<std::array<std::uint32_t, kMaxBindingsPerAction>, kActionCount> m_binds{};
    std::array<std::uint8_t, kActionCount> m_bindCounts{};

    // Cached action-down state (updated by Consume()).
    std::array<bool, kActionCount> m_actionDown{};

    // Discrete action events (pressed/released) produced by the last Consume().
    std::array<ActionEvent, kMaxActionEvents> m_actionEvents{};
    std::size_t m_actionEventCount = 0;
    std::size_t m_droppedActionEvents = 0;
};

} // namespace colony::input
